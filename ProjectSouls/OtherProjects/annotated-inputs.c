/**************************************************************************//**
 *
 * @file inputs.c
 *
 * @author Tyler Roelfs
 *
 * @brief Interrupt Service Routines for timer interrupts and pin change
 *      interrupts
 *
 ******************************************************************************/
 /*
 * InterruptLab (c) 2021-24 Christopher A. Bohn
 * InterruptLab solution (c) the above-named student(s)
 *
 * Assignment and starter code licensed under the Apache License,
 * Version 2.0 (http://www.apache.org/licenses/LICENSE-2.0).
 */
 #include <CowPi.h>
 #include "interrupt_support.h"
 #include "inputs.h"
 #include "character_selector.h"
 #include "message_editor.h"
 void handle_keypad(void);
 void handle_right_button(void);
 void handle_left_button(void);
 void handle_led_timer(void);
 void handle_character_timer(void);
 void reset_timers(void);
 #define CHARACTER_TIMER (1)
 #define LED_TIMER       (2)
 uint8_t volatile supplemental_counter;
 /**
 * Registers ISR for pin change interrupts, configures timers, and enables timer 
interrupts.
 */
 void initialize_interrupts(void) {
    register_pin_ISR((0xf << 10), handle_keypad);
    register_pin_ISR((0x1 << 3), handle_right_button);
    register_pin_ISR((0x1 << 2), handle_left_button);
    register_timer_ISR(LED_TIMER, 8000, handle_led_timer);
    register_timer_ISR(CHARACTER_TIMER, 2000000, handle_character_timer);
 }
 /**
 * Sets timer counters and the supplemental counter to 0.
 */
 void reset_timers(void) {
    supplemental_counter = 0;
    reset_timer(LED_TIMER);
    reset_timer(CHARACTER_TIMER);
 }
/**
 * ISR to handle the periodic interrupts fired by the timer used for deluminating 
the LED.
 */
 void handle_led_timer(void) {
    supplemental_counter++;
    if (supplemental_counter == 32) {
        cowpi_deluminate_right_led();
        supplemental_counter = 0;
    }
 }
 /**
 * ISR to handle the periodic interrupts fired by the timer used for character 
finalization.
 */
 void handle_character_timer(void) {
    finalize_character();
 }
 /**
 * ISR to handle pin change interrupts generated by the matrix keypad.
 */
 void handle_keypad(void) {
    debounce_interrupt({
        static char debounce_key = 0xF0;
        char key;
        while ((key = cowpi_get_keypress()) == debounce_key) {}     // busy-wait 
through the race condition
        debounce_key = key;
        /* YOUR CODE GOES HERE */
        reset_timer(CHARACTER_TIMER);
        if (key != '\0') {
            if (key == 'D') {
                send_message_to_output();
            } else {
                update_character(key);
                cowpi_illuminate_right_led();
                reset_timers();
            }
        }
    });
 }
 /**
 * ISR to handle pin change interrupts generated by the right pushbutton.
 */
 void handle_right_button(void) {
    debounce_interrupt({
        static bool debounce_is_pressed = false;
        bool is_pressed;
        while ((is_pressed = cowpi_right_button_is_pressed()) == 
debounce_is_pressed) {}    // busy-wait through the race condition
        debounce_is_pressed = is_pressed;
        /* YOUR CODE GOES HERE */
        if (debounce_is_pressed == true) {
            reset_timers();
            finalize_character();
        }
    });
 }
 /**
 * ISR to handle pin change interrupts generated by the left pushbutton.
 */
 void handle_left_button(void) {
    debounce_interrupt({
        static bool debounce_is_pressed = false;
        bool is_pressed;
        while ((is_pressed = cowpi_left_button_is_pressed()) == 
debounce_is_pressed) {}     // busy-wait through the race condition
        debounce_is_pressed = is_pressed;
        /* YOUR CODE GOES HERE */
        if (debounce_is_pressed == true) {
            reset_timers();
            delete_character();
        }
    });
 }